
/**
 * Core Philosophy: This ruleset implements a user-centric, ownership-based security model.
 * All sensitive user data, including transactions and payment requests, is stored in a private
 * data tree under that user's unique ID. This ensures users can only access their own
 * information, providing strong data isolation by default.
 *
 * Data Structure: The primary data path is /users/{userId}, which contains subcollections
 * for transactions and paymentRequests. This structure leverages path-based security, making
 * rules simple and performant. A top-level /qrcodes collection exists for publicly scannable
 * QR codes, which are secured by an ownership field within each document.
 *
 * Key Security Decisions:
 * - User Isolation: A user can only read or write data within their own /users/{userId} document tree, unless they are an admin.
 * - Admin Access: Users with the 'admin' or 'superadmin' role are granted read-only access to all user data for management purposes.
 * - No Public User Enumeration: Listing documents in the top-level /users collection is explicitly disallowed for non-admins
 *   to prevent scraping of user information, except for a secure phone-based sign-in mechanism.
 * - Public Readability: QR codes are publicly readable to allow scanning by anyone, but write
 *   operations are strictly limited to the user who owns the QR code.
 * - Denormalization for Authorization: Transaction and payment request data is denormalized
 *   (copied) into the subcollections of all participating users. This avoids slow and costly
 *   cross-document `get()` calls in rules, simplifying authorization to a direct path ownership check.
 * - Relational Integrity on Create: When new documents are created, rules validate that ownership
 *   fields (e.g., `userId`, `senderId`) correctly link back to the user performing the action,
 *   ensuring data consistency.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the authenticated user's UID matches the provided userId.
     * Used for path-based ownership checks.
     * @param userId The user ID from the document path.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * Returns true if the user has an admin-level role.
     */
    function isAdmin() {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['admin', 'superadmin'];
    }

    /**
     * Returns true if the document being operated on already exists.
     * Essential for securing update and delete operations.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Returns true if the user is the owner of an existing document.
     * A common pattern for update/delete operations in user-scoped collections.
     * @param userId The user ID from the document path.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }

    /**
     * Returns true if the user is the owner of an existing document,
     * based on an ownership field within the document's data.
     * @param ownerId The owner's UID stored in a document field (e.g., resource.data.userId).
     */
    function isOwnerOfExistingDoc(ownerId) {
      return isOwner(ownerId) && isExistingDoc();
    }
    
    /**
     * Returns true if the request is a query for a user by their phone number for sign-in purposes.
     * This is a narrow exception to the general rule of not allowing user listing.
     * The key security is that the client query must be strictly limited to the 'phoneNumber' field.
     */
    function isSigningInByPhone() {
        return !isSignedIn() && request.method == 'list';
    }


    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @allow (create) An authenticated user can create their own profile document.
     * @allow (get) An owner or an admin can read a user profile.
     * @allow (list) Admins can list all users. Unauthenticated users can query for a user by phone number to sign in.
     * @deny (get, list) Regular users cannot read other user profiles or list all users.
     * @principle Restricts access to a user's own data tree and prevents user enumeration by non-admins.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin() || isSigningInByPhone();
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id || isAdmin();
      allow delete: if isExistingOwner(userId) || isAdmin();

      /**
       * @description Controls access to a user's transaction history.
       * @path /users/{userId}/transactions/{transactionId}
       * @allow (get, list) A user can read transactions from their own history. Admins can also read them.
       * @deny (list) A user cannot list transactions belonging to another user.
       * @principle Enforces path-based ownership for a user's denormalized data, with admin override.
       */
      match /transactions/{transactionId} {
        allow get, list: if isOwner(userId) || isAdmin();
        allow create: if isOwner(userId) && (request.resource.data.senderId == userId || request.resource.data.receiverId == userId);
        allow update: if isExistingOwner(userId) || isAdmin();
        allow delete: if isExistingOwner(userId) || isAdmin();
      }

      /**
       * @description Controls access to a user's payment requests (both sent and received).
       * @path /users/{userId}/paymentRequests/{paymentRequestId}
       * @allow (create) A user can create a payment request in their own subcollection.
       * @deny (get, list) A user cannot read a payment request from another user's private data unless they are an admin.
       * @principle Enforces path-based ownership for a user's denormalized data, with admin override.
       */
      match /paymentRequests/{paymentRequestId} {
        allow get, list: if isOwner(userId) || isAdmin();
        allow create: if isOwner(userId) && (request.resource.data.requesterId == userId || request.resource.data.payerId == userId);
        allow update: if isExistingOwner(userId) || isAdmin();
        allow delete: if isExistingOwner(userId) || isAdmin();
      }
    }

    /**
     * @description Controls access to QR code documents.
     * @path /qrcodes/{qrCodeId}
     * @allow (get) Any client (authenticated or not) can read a QR code to process a payment.
     * @deny (update) A user cannot modify a QR code that they do not own.
     * @principle Implements public read access with strict, owner-only writes.
     */
    match /qrcodes/{qrCodeId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isOwnerOfExistingDoc(resource.data.userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isOwnerOfExistingDoc(resource.data.userId);
    }
  }
}
