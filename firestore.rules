/**
 * Core Philosophy: This ruleset implements a user-centric, ownership-based security model.
 * All sensitive user data, including transactions and payment requests, is stored in a private
 * data tree under that user's unique ID. This ensures users can only access their own
 * information, providing strong data isolation by default.
 *
 * Data Structure: The primary data path is /users/{userId}, which contains subcollections
 * for transactions and paymentRequests. This structure leverages path-based security, making
 * rules simple and performant. A top-level /qrcodes collection exists for publicly scannable
 * QR codes, which are secured by an ownership field within each document.
 *
 * Key Security Decisions:
 * - User Isolation: A user can only read or write data within their own /users/{userId} document tree.
 * - No User Enumeration: Listing documents in the top-level /users collection is explicitly disallowed
 *   to prevent scraping of user information.
 * - Public Readability: QR codes are publicly readable to allow scanning by anyone, but write
 *   operations are strictly limited to the user who owns the QR code.
 * - Denormalization for Authorization: Transaction and payment request data is denormalized
 *   (copied) into the subcollections of all participating users. This avoids slow and costly
 *   cross-document `get()` calls in rules, simplifying authorization to a direct path ownership check.
 * - Relational Integrity on Create: When new documents are created, rules validate that ownership
 *   fields (e.g., `userId`, `senderId`) correctly link back to the user performing the action,
 *   ensuring data consistency.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the authenticated user's UID matches the provided userId.
     * Used for path-based ownership checks.
     * @param userId The user ID from the document path.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the document being operated on already exists.
     * Essential for securing update and delete operations.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Returns true if the user is the owner of an existing document.
     * A common pattern for update/delete operations in user-scoped collections.
     * @param userId The user ID from the document path.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }

    /**
     * Returns true if the user is the owner of an existing document,
     * based on an ownership field within the document's data.
     * @param ownerId The owner's UID stored in a document field (e.g., resource.data.userId).
     */
    function isOwnerOfExistingDoc(ownerId) {
      return isOwner(ownerId) && isExistingDoc();
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @allow (create) An authenticated user can create their own profile document.
     * @deny (get) An authenticated user cannot read another user's profile.
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);

      /**
       * @description Controls access to a user's transaction history.
       * @path /users/{userId}/transactions/{transactionId}
       * @allow (get) A user can read a transaction from their own history.
       * @deny (list) A user cannot list transactions belonging to another user.
       * @principle Enforces path-based ownership for a user's denormalized data.
       */
      match /transactions/{transactionId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && (request.resource.data.senderId == userId || request.resource.data.receiverId == userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Controls access to a user's payment requests (both sent and received).
       * @path /users/{userId}/paymentRequests/{paymentRequestId}
       * @allow (create) A user can create a payment request in their own subcollection.
       * @deny (get) A user cannot read a payment request from another user's private data.
       * @principle Enforces path-based ownership for a user's denormalized data.
       */
      match /paymentRequests/{paymentRequestId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && (request.resource.data.requesterId == userId || request.resource.data.payerId == userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
      }
    }

    /**
     * @description Controls access to QR code documents.
     * @path /qrcodes/{qrCodeId}
     * @allow (get) Any client (authenticated or not) can read a QR code to process a payment.
     * @deny (update) A user cannot modify a QR code that they do not own.
     * @principle Implements public read access with strict, owner-only writes.
     */
    match /qrcodes/{qrCodeId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isOwnerOfExistingDoc(resource.data.userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isOwnerOfExistingDoc(resource.data.userId);
    }
  }
}